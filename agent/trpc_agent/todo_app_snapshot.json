{"server/src/schema.ts": "\nimport { z } from 'zod';\n\n// Todo item schema\nexport const todoItemSchema = z.object({\n  id: z.number().optional(),\n  title: z.string().min(1, \"Title is required\"),\n  completed: z.boolean().default(false),\n  createdAt: z.date().optional(),\n  updatedAt: z.date().optional(),\n});\n\nexport type TodoItem = z.infer<typeof todoItemSchema>;\n\n// Create todo input schema\nexport const createTodoInputSchema = z.object({\n  title: z.string().min(1, \"Title is required\"),\n});\n\nexport type CreateTodoInput = z.infer<typeof createTodoInputSchema>;\n\n// Update todo input schema\nexport const updateTodoInputSchema = z.object({\n  id: z.number(),\n  title: z.string().min(1, \"Title is required\").optional(),\n  completed: z.boolean().optional(),\n});\n\nexport type UpdateTodoInput = z.infer<typeof updateTodoInputSchema>;\n\n// Get todo by id input schema\nexport const getTodoByIdInputSchema = z.object({\n  id: z.number(),\n});\n\nexport type GetTodoByIdInput = z.infer<typeof getTodoByIdInputSchema>;\n\n// Delete todo input schema\nexport const deleteTodoInputSchema = z.object({\n  id: z.number(),\n});\n\nexport type DeleteTodoInput = z.infer<typeof deleteTodoInputSchema>;\n\n// List todos input schema for pagination and filtering\nexport const listTodosInputSchema = z.object({\n  limit: z.number().min(1).max(100).default(10),\n  offset: z.number().min(0).default(0),\n  completed: z.boolean().optional(),\n});\n\nexport type ListTodosInput = z.infer<typeof listTodosInputSchema>;\n", "server/src/db/schema.ts": "\nimport { serial, text, boolean, timestamp, pgTable } from \"drizzle-orm/pg-core\";\n\nexport const todosTable = pgTable(\"todos\", {\n  id: serial(\"id\").primaryKey(),\n  title: text(\"title\").notNull(),\n  completed: boolean(\"completed\").default(false).notNull(),\n  created_at: timestamp(\"created_at\").defaultNow().notNull(),\n  updated_at: timestamp(\"updated_at\").defaultNow().notNull()\n});\n", "server/src/handlers/create_todo.ts": "\nimport { type CreateTodoInput } from \"../schema\";\nimport { type TodoItem } from \"../schema\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { eq } from \"drizzle-orm\";\n\n/**\n * Creates a new todo item based on the provided input\n * @param input The todo item creation input\n * @returns The created todo item\n */\nexport async function createTodo(input: CreateTodoInput): Promise<TodoItem> {\n  const now = new Date();\n  \n  const result = await db.insert(todosTable)\n    .values({\n      title: input.title,\n      completed: false,\n      created_at: now,\n      updated_at: now\n    })\n    .returning();\n\n  if (!result || result.length === 0) {\n    throw new Error(\"Failed to create todo item\");\n  }\n\n  // Transform the database result to match the TodoItem type\n  return {\n    id: result[0].id,\n    title: result[0].title,\n    completed: result[0].completed,\n    createdAt: result[0].created_at,\n    updatedAt: result[0].updated_at\n  };\n}\n", "server/src/handlers/update_todo.ts": "\nimport { type UpdateTodoInput } from \"../schema\";\nimport { type TodoItem } from \"../schema\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { eq } from \"drizzle-orm\";\n\nexport async function updateTodo(input: UpdateTodoInput): Promise<TodoItem> {\n  const { id, ...updates } = input;\n  \n  // Create an update object with only the fields that are provided\n  const updateData: any = {\n    updated_at: new Date(),\n  };\n  \n  if (updates.title !== undefined) {\n    updateData.title = updates.title;\n  }\n  \n  if (updates.completed !== undefined) {\n    updateData.completed = updates.completed;\n  }\n\n  // Perform the update\n  await db.update(todosTable)\n    .set(updateData)\n    .where(eq(todosTable.id, id));\n\n  // Fetch the updated todo\n  const updatedTodos = await db.select()\n    .from(todosTable)\n    .where(eq(todosTable.id, id))\n    .limit(1);\n  \n  if (updatedTodos.length === 0) {\n    throw new Error(`Todo with id ${id} not found`);\n  }\n  \n  const todo = updatedTodos[0];\n  \n  // Map the database todo to the TodoItem type\n  return {\n    id: todo.id,\n    title: todo.title,\n    completed: todo.completed,\n    createdAt: todo.created_at,\n    updatedAt: todo.updated_at\n  };\n}\n", "server/src/handlers/get_todo_by_id.ts": "\nimport { type GetTodoByIdInput, type TodoItem } from \"../schema\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { eq } from \"drizzle-orm\";\n\n/**\n * Fetches a todo item by its ID\n * @param input The input containing the todo ID to fetch\n * @returns The todo item or null if not found\n */\nexport async function getTodoById(input: GetTodoByIdInput): Promise<TodoItem | null> {\n  const { id } = input;\n  \n  const results = await db\n    .select()\n    .from(todosTable)\n    .where(eq(todosTable.id, id))\n    .limit(1);\n  \n  if (results.length === 0) {\n    return null;\n  }\n  \n  const todo = results[0];\n  \n  // Transform the database result to match TodoItem schema\n  return {\n    id: todo.id,\n    title: todo.title,\n    completed: todo.completed,\n    createdAt: todo.created_at,\n    updatedAt: todo.updated_at,\n  };\n}\n", "server/src/handlers/delete_todo.ts": "\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { eq } from \"drizzle-orm\";\nimport { type DeleteTodoInput } from \"../schema\";\n\nexport async function deleteTodo(input: DeleteTodoInput): Promise<{ success: boolean }> {\n  try {\n    const { id } = input;\n    \n    // Check if the todo exists before deletion\n    const existingTodo = await db.select()\n      .from(todosTable)\n      .where(eq(todosTable.id, id))\n      .limit(1);\n    \n    if (existingTodo.length === 0) {\n      return { success: false };\n    }\n    \n    // Delete the todo item\n    await db.delete(todosTable)\n      .where(eq(todosTable.id, id));\n    \n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting todo:\", error);\n    return { success: false };\n  }\n}\n", "server/src/handlers/list_todos.ts": "\nimport { type ListTodosInput } from \"../schema\";\nimport { type TodoItem } from \"../schema\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { eq, and, count } from \"drizzle-orm\";\n\n/**\n * List todos with optional filtering and pagination\n * \n * @param input ListTodosInput with limit, offset, and optional completed filter\n * @returns Promise with todos array and total count\n */\nexport async function listTodos(input: ListTodosInput): Promise<{ todos: TodoItem[], total: number }> {\n  const { limit, offset, completed } = input;\n  \n  // Build query conditions\n  const whereConditions = [];\n  if (completed !== undefined) {\n    whereConditions.push(eq(todosTable.completed, completed));\n  }\n  \n  // Build where clause\n  const whereClause = whereConditions.length > 0 \n    ? and(...whereConditions) \n    : undefined;\n  \n  // Get paginated todos\n  const todos = await db\n    .select()\n    .from(todosTable)\n    .where(whereClause)\n    .limit(limit)\n    .offset(offset)\n    .orderBy(todosTable.created_at);\n  \n  // Get total count for pagination info\n  const [{ value: total }] = await db\n    .select({ value: count() })\n    .from(todosTable)\n    .where(whereClause);\n  \n  // Map database results to TodoItem schema\n  const mappedTodos: TodoItem[] = todos.map(todo => ({\n    id: todo.id,\n    title: todo.title,\n    completed: todo.completed,\n    createdAt: todo.created_at,\n    updatedAt: todo.updated_at\n  }));\n  \n  return {\n    todos: mappedTodos,\n    total: Number(total)\n  };\n}\n", "server/src/tests/get_todo_by_id.test.ts": "\nimport { afterEach, beforeEach, describe, expect, it } from \"bun:test\";\nimport { resetDB, createDB } from \"../helpers\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { type GetTodoByIdInput } from \"../schema\";\nimport { getTodoById } from \"../handlers/get_todo_by_id\";\n\ndescribe(\"getTodoById\", () => {\n  beforeEach(createDB);\n  afterEach(resetDB);\n\n  it(\"should return null when todo with given ID does not exist\", async () => {\n    const input: GetTodoByIdInput = { id: 999 };\n    const result = await getTodoById(input);\n    expect(result).toBeNull();\n  });\n\n  it(\"should return the todo when it exists\", async () => {\n    // Create a test todo\n    const todoData = {\n      title: \"Test Todo\",\n      completed: false\n    };\n    \n    const insertedTodos = await db.insert(todosTable).values(todoData).returning();\n    const insertedTodo = insertedTodos[0];\n    \n    const input: GetTodoByIdInput = { id: insertedTodo.id };\n    const result = await getTodoById(input);\n    \n    expect(result).not.toBeNull();\n    expect(result?.id).toBe(insertedTodo.id);\n    expect(result?.title).toBe(todoData.title);\n    expect(result?.completed).toBe(todoData.completed);\n    expect(result?.createdAt instanceof Date).toBe(true);\n    expect(result?.updatedAt instanceof Date).toBe(true);\n  });\n\n  it(\"should correctly transform database fields to match the TodoItem schema\", async () => {\n    // Create a test todo with explicit completed state\n    const todoData = {\n      title: \"Complete this task\",\n      completed: true\n    };\n    \n    const insertedTodos = await db.insert(todosTable).values(todoData).returning();\n    const insertedTodo = insertedTodos[0];\n    \n    const input: GetTodoByIdInput = { id: insertedTodo.id };\n    const result = await getTodoById(input);\n    \n    // Verify the field transformation\n    expect(result).not.toBeNull();\n    expect(result).toEqual({\n      id: insertedTodo.id,\n      title: insertedTodo.title,\n      completed: insertedTodo.completed,\n      createdAt: insertedTodo.created_at,\n      updatedAt: insertedTodo.updated_at,\n    });\n  });\n});\n", "server/src/tests/create_todo.test.ts": "\nimport { afterEach, beforeEach, describe, expect, it } from \"bun:test\";\nimport { resetDB, createDB } from \"../helpers\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { type CreateTodoInput } from \"../schema\";\nimport { createTodo } from \"../handlers/create_todo\";\n\ndescribe(\"createTodo\", () => {\n  beforeEach(createDB);\n  afterEach(resetDB);\n\n  it(\"should create a todo item with the provided title\", async () => {\n    const input: CreateTodoInput = { title: \"Buy groceries\" };\n    \n    const result = await createTodo(input);\n    \n    expect(result.id).toBeGreaterThan(0);\n    expect(result.title).toEqual(\"Buy groceries\");\n    expect(result.completed).toBe(false);\n    expect(result.createdAt).toBeInstanceOf(Date);\n    expect(result.updatedAt).toBeInstanceOf(Date);\n  });\n\n  it(\"should save the todo item to the database\", async () => {\n    const input: CreateTodoInput = { title: \"Clean the house\" };\n    \n    await createTodo(input);\n    \n    const todos = await db.select().from(todosTable);\n    expect(todos).toHaveLength(1);\n    expect(todos[0].title).toEqual(\"Clean the house\");\n    expect(todos[0].completed).toBe(false);\n  });\n\n  it(\"should handle long title inputs\", async () => {\n    const longTitle = \"This is a very long title that contains more than fifty characters to test the handler with longer input strings\";\n    const input: CreateTodoInput = { title: longTitle };\n    \n    const result = await createTodo(input);\n    \n    expect(result.title).toEqual(longTitle);\n  });\n\n  it(\"should create multiple todo items independently\", async () => {\n    const input1: CreateTodoInput = { title: \"Task 1\" };\n    const input2: CreateTodoInput = { title: \"Task 2\" };\n    const input3: CreateTodoInput = { title: \"Task 3\" };\n    \n    await createTodo(input1);\n    await createTodo(input2);\n    await createTodo(input3);\n    \n    const todos = await db.select().from(todosTable);\n    expect(todos).toHaveLength(3);\n    \n    // Verify the todos are stored in order with sequential IDs\n    expect(todos[0].title).toEqual(\"Task 1\");\n    expect(todos[1].title).toEqual(\"Task 2\");\n    expect(todos[2].title).toEqual(\"Task 3\");\n  });\n});\n", "server/src/tests/delete_todo.test.ts": "\nimport { afterEach, beforeEach, describe, expect, it } from \"bun:test\";\nimport { resetDB, createDB } from \"../helpers\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { type DeleteTodoInput } from \"../schema\";\nimport { deleteTodo } from \"../handlers/delete_todo\";\n\ndescribe(\"deleteTodo\", () => {\n  beforeEach(createDB);\n  afterEach(resetDB);\n\n  // Helper function to create a test todo\n  const createTestTodo = async (title: string, completed = false) => {\n    const [todo] = await db.insert(todosTable)\n      .values({ \n        title, \n        completed,\n        created_at: new Date(),\n        updated_at: new Date()\n      })\n      .returning();\n    \n    return todo;\n  };\n\n  it(\"should successfully delete an existing todo\", async () => {\n    // Create a test todo\n    const todo = await createTestTodo(\"Test Todo\");\n    \n    // Verify todo exists\n    let todos = await db.select().from(todosTable);\n    expect(todos.length).toBe(1);\n    \n    // Delete the todo\n    const input: DeleteTodoInput = { id: todo.id };\n    const result = await deleteTodo(input);\n    \n    // Check result\n    expect(result.success).toBe(true);\n    \n    // Verify todo was deleted\n    todos = await db.select().from(todosTable);\n    expect(todos.length).toBe(0);\n  });\n\n  it(\"should return false when trying to delete non-existent todo\", async () => {\n    const input: DeleteTodoInput = { id: 999 }; // Non-existent ID\n    const result = await deleteTodo(input);\n    \n    expect(result.success).toBe(false);\n  });\n\n  it(\"should only delete the specified todo\", async () => {\n    // Create multiple todos\n    const todo1 = await createTestTodo(\"Todo 1\");\n    const todo2 = await createTestTodo(\"Todo 2\");\n    const todo3 = await createTestTodo(\"Todo 3\");\n    \n    // Delete the second todo\n    const input: DeleteTodoInput = { id: todo2.id };\n    const result = await deleteTodo(input);\n    \n    // Check result\n    expect(result.success).toBe(true);\n    \n    // Verify only the second todo was deleted\n    const remainingTodos = await db.select().from(todosTable);\n    expect(remainingTodos.length).toBe(2);\n    expect(remainingTodos.map(t => t.id)).toContain(todo1.id);\n    expect(remainingTodos.map(t => t.id)).not.toContain(todo2.id);\n    expect(remainingTodos.map(t => t.id)).toContain(todo3.id);\n  });\n});\n", "server/src/tests/list_todos.test.ts": "\nimport { afterEach, beforeEach, describe, expect, it } from \"bun:test\";\nimport { resetDB, createDB } from \"../helpers\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { listTodos } from \"../handlers/list_todos\";\nimport { type ListTodosInput } from \"../schema\";\n\ndescribe(\"listTodos handler\", () => {\n  beforeEach(async () => {\n    await createDB();\n    \n    // Seed the database with test data\n    await db.insert(todosTable).values([\n      { title: \"Complete project\", completed: false },\n      { title: \"Buy groceries\", completed: true },\n      { title: \"Read book\", completed: false },\n      { title: \"Go to gym\", completed: true },\n      { title: \"Call mom\", completed: false }\n    ]);\n  });\n\n  afterEach(resetDB);\n\n  it(\"should return all todos with default pagination\", async () => {\n    const input: ListTodosInput = { limit: 10, offset: 0 };\n    const result = await listTodos(input);\n    \n    expect(result.todos).toHaveLength(5);\n    expect(result.total).toBe(5);\n    expect(result.todos[0].title).toBe(\"Complete project\");\n    expect(result.todos[1].title).toBe(\"Buy groceries\");\n  });\n\n  it(\"should paginate results correctly\", async () => {\n    const input: ListTodosInput = { limit: 2, offset: 1 };\n    const result = await listTodos(input);\n    \n    expect(result.todos).toHaveLength(2);\n    expect(result.total).toBe(5);\n    expect(result.todos[0].title).toBe(\"Buy groceries\");\n    expect(result.todos[1].title).toBe(\"Read book\");\n  });\n\n  it(\"should filter by completed status (true)\", async () => {\n    const input: ListTodosInput = { limit: 10, offset: 0, completed: true };\n    const result = await listTodos(input);\n    \n    expect(result.todos).toHaveLength(2);\n    expect(result.total).toBe(2);\n    expect(result.todos.every(todo => todo.completed === true)).toBeTruthy();\n  });\n\n  it(\"should filter by completed status (false)\", async () => {\n    const input: ListTodosInput = { limit: 10, offset: 0, completed: false };\n    const result = await listTodos(input);\n    \n    expect(result.todos).toHaveLength(3);\n    expect(result.total).toBe(3);\n    expect(result.todos.every(todo => todo.completed === false)).toBeTruthy();\n  });\n\n  it(\"should handle empty results correctly\", async () => {\n    // Clear database first\n    await resetDB();\n    await createDB();\n    \n    const input: ListTodosInput = { limit: 10, offset: 0 };\n    const result = await listTodos(input);\n    \n    expect(result.todos).toHaveLength(0);\n    expect(result.total).toBe(0);\n  });\n\n  it(\"should handle pagination beyond available data\", async () => {\n    const input: ListTodosInput = { limit: 10, offset: 10 };\n    const result = await listTodos(input);\n    \n    expect(result.todos).toHaveLength(0);\n    expect(result.total).toBe(5); // Should still return correct total\n  });\n\n  it(\"should properly map database fields to schema fields\", async () => {\n    const input: ListTodosInput = { limit: 1, offset: 0 };\n    const result = await listTodos(input);\n    \n    expect(result.todos[0]).toHaveProperty(\"id\");\n    expect(result.todos[0]).toHaveProperty(\"title\");\n    expect(result.todos[0]).toHaveProperty(\"completed\");\n    expect(result.todos[0]).toHaveProperty(\"createdAt\");\n    expect(result.todos[0]).toHaveProperty(\"updatedAt\");\n  });\n});\n", "server/src/tests/update_todo.test.ts": "\nimport { afterEach, beforeEach, describe, expect, it } from \"bun:test\";\nimport { resetDB, createDB } from \"../helpers\";\nimport { db } from \"../db\";\nimport { todosTable } from \"../db/schema\";\nimport { updateTodo } from \"../handlers/update_todo\";\nimport type { UpdateTodoInput } from \"../schema\";\nimport { eq } from \"drizzle-orm\";\n\ndescribe(\"updateTodo\", () => {\n  beforeEach(async () => {\n    await createDB();\n    \n    // Insert test data\n    await db.insert(todosTable).values([\n      { \n        id: 1, \n        title: \"Original Todo\", \n        completed: false,\n        created_at: new Date(\"2023-01-01T12:00:00Z\"),\n        updated_at: new Date(\"2023-01-01T12:00:00Z\")\n      }\n    ]);\n  });\n\n  afterEach(resetDB);\n\n  it(\"should update todo title\", async () => {\n    const input: UpdateTodoInput = { id: 1, title: \"Updated Todo\" };\n    const result = await updateTodo(input);\n    \n    expect(result.id).toEqual(1);\n    expect(result.title).toEqual(\"Updated Todo\");\n    expect(result.completed).toEqual(false);\n    \n    // Verify in database\n    const todos = await db.select().from(todosTable).where(eq(todosTable.id, 1));\n    expect(todos[0].title).toEqual(\"Updated Todo\");\n  });\n\n  it(\"should update todo completed status\", async () => {\n    const input: UpdateTodoInput = { id: 1, completed: true };\n    const result = await updateTodo(input);\n    \n    expect(result.id).toEqual(1);\n    expect(result.title).toEqual(\"Original Todo\");\n    expect(result.completed).toEqual(true);\n    \n    // Verify in database\n    const todos = await db.select().from(todosTable).where(eq(todosTable.id, 1));\n    expect(todos[0].completed).toEqual(true);\n  });\n\n  it(\"should update both title and completed status\", async () => {\n    const input: UpdateTodoInput = { id: 1, title: \"Fully Updated\", completed: true };\n    const result = await updateTodo(input);\n    \n    expect(result.id).toEqual(1);\n    expect(result.title).toEqual(\"Fully Updated\");\n    expect(result.completed).toEqual(true);\n  });\n\n  it(\"should update the updated_at timestamp\", async () => {\n    // Store the original updated_at timestamp\n    const beforeUpdate = await db.select({ updated_at: todosTable.updated_at })\n      .from(todosTable)\n      .where(eq(todosTable.id, 1));\n    const originalTimestamp = beforeUpdate[0].updated_at;\n    \n    // Wait a bit to ensure timestamp difference\n    await new Promise(resolve => setTimeout(resolve, 10));\n    \n    // Update the todo\n    const input: UpdateTodoInput = { id: 1, title: \"New Title\" };\n    await updateTodo(input);\n    \n    // Check that updated_at changed\n    const afterUpdate = await db.select({ updated_at: todosTable.updated_at })\n      .from(todosTable)\n      .where(eq(todosTable.id, 1));\n    const newTimestamp = afterUpdate[0].updated_at;\n    \n    expect(newTimestamp.getTime()).toBeGreaterThan(originalTimestamp.getTime());\n  });\n\n  it(\"should throw an error when updating non-existent todo\", async () => {\n    const input: UpdateTodoInput = { id: 999, title: \"This doesn't exist\" };\n    \n    await expect(updateTodo(input)).rejects.toThrow(\"Todo with id 999 not found\");\n  });\n});\n", "server/src/index.ts": "\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport 'dotenv/config';\nimport cors from 'cors';\nimport superjson from 'superjson';\n\n// Import schema types\nimport { \n  createTodoInputSchema, \n  updateTodoInputSchema, \n  getTodoByIdInputSchema,\n  deleteTodoInputSchema,\n  listTodosInputSchema\n} from './schema';\n\n// Import handlers\nimport { createTodo } from './handlers/create_todo';\nimport { updateTodo } from './handlers/update_todo';\nimport { getTodoById } from './handlers/get_todo_by_id';\nimport { deleteTodo } from './handlers/delete_todo';\nimport { listTodos } from './handlers/list_todos';\n\nconst t = initTRPC.create({\n  transformer: superjson,\n});\n\nconst publicProcedure = t.procedure;\nconst router = t.router;\n\nconst appRouter = router({\n  createTodo: publicProcedure\n    .input(createTodoInputSchema)\n    .mutation(({ input }) => createTodo(input)),\n  \n  updateTodo: publicProcedure\n    .input(updateTodoInputSchema)\n    .mutation(({ input }) => updateTodo(input)),\n  \n  getTodoById: publicProcedure\n    .input(getTodoByIdInputSchema)\n    .query(({ input }) => getTodoById(input)),\n  \n  deleteTodo: publicProcedure\n    .input(deleteTodoInputSchema)\n    .mutation(({ input }) => deleteTodo(input)),\n  \n  listTodos: publicProcedure\n    .input(listTodosInputSchema)\n    .query(({ input }) => listTodos(input)),\n});\n\nexport type AppRouter = typeof appRouter;\n\nasync function start() {\n  const port = process.env['PORT'] || 2022;\n  const server = createHTTPServer({\n    middleware: cors(),\n    router: appRouter,\n    createContext() {\n      return {};\n    },\n  });\n  server.listen(port);\n  console.log(`TRPC server listening at port: ${port}`);\n}\n\nstart();\n", "client/src/components/TodoItem.tsx": "\nimport { useState } from 'react';\nimport { Checkbox } from './ui/checkbox';\nimport { Button } from './ui/button';\nimport { Input } from './ui/input';\nimport { TodoItem } from '../../../server/src/schema';\nimport { trpc } from '@/utils/trpc';\nimport { Pencil, Trash2, Check, X } from 'lucide-react';\n\ninterface TodoItemProps {\n  todo: TodoItem;\n  onDelete: (id: number) => void;\n  onUpdate: (id: number, updates: { title?: string; completed?: boolean }) => void;\n}\n\nexport function TodoItemComponent({ todo, onDelete, onUpdate }: TodoItemProps) {\n  const [isEditing, setIsEditing] = useState(false);\n  const [editValue, setEditValue] = useState(todo.title);\n\n  const handleToggleComplete = () => {\n    onUpdate(todo.id!, { completed: !todo.completed });\n  };\n\n  const handleEdit = () => {\n    setIsEditing(true);\n  };\n\n  const handleSave = () => {\n    if (editValue.trim() !== '') {\n      onUpdate(todo.id!, { title: editValue });\n      setIsEditing(false);\n    }\n  };\n\n  const handleCancel = () => {\n    setEditValue(todo.title);\n    setIsEditing(false);\n  };\n\n  return (\n    <div className=\"flex items-center justify-between gap-2 p-3 border-b\">\n      <div className=\"flex items-center gap-3 flex-1\">\n        <Checkbox \n          checked={todo.completed} \n          onCheckedChange={handleToggleComplete}\n        />\n        \n        {isEditing ? (\n          <Input \n            value={editValue}\n            onChange={(e) => setEditValue(e.target.value)}\n            className=\"flex-1\"\n          />\n        ) : (\n          <span className={`flex-1 ${todo.completed ? 'line-through text-gray-400' : ''}`}>\n            {todo.title}\n          </span>\n        )}\n      </div>\n      \n      <div className=\"flex gap-1\">\n        {isEditing ? (\n          <>\n            <Button variant=\"ghost\" size=\"icon\" onClick={handleSave}>\n              <Check className=\"size-4\" />\n            </Button>\n            <Button variant=\"ghost\" size=\"icon\" onClick={handleCancel}>\n              <X className=\"size-4\" />\n            </Button>\n          </>\n        ) : (\n          <>\n            <Button variant=\"ghost\" size=\"icon\" onClick={handleEdit}>\n              <Pencil className=\"size-4\" />\n            </Button>\n            <Button variant=\"ghost\" size=\"icon\" onClick={() => onDelete(todo.id!)}>\n              <Trash2 className=\"size-4\" />\n            </Button>\n          </>\n        )}\n      </div>\n    </div>\n  );\n}\n", "client/src/components/TodoList.tsx": "\nimport { useState, useEffect } from 'react';\nimport { TodoItem as TodoItemType } from '../../../server/src/schema';\nimport { TodoItemComponent } from './TodoItem';\nimport { Card, CardHeader, CardTitle, CardContent } from './ui/card';\nimport { Separator } from './ui/separator';\nimport { trpc } from '@/utils/trpc';\n\ninterface TodoListProps {\n  todos: TodoItemType[];\n  onDelete: (id: number) => void;\n  onUpdate: (id: number, updates: { title?: string; completed?: boolean }) => void;\n  isLoading: boolean;\n}\n\nexport function TodoList({ todos, onDelete, onUpdate, isLoading }: TodoListProps) {\n  if (isLoading) {\n    return (\n      <Card className=\"min-h-[300px] w-full max-w-md\">\n        <CardHeader>\n          <CardTitle>Loading todos...</CardTitle>\n        </CardHeader>\n      </Card>\n    );\n  }\n\n  if (!todos.length) {\n    return (\n      <Card className=\"min-h-[300px] w-full max-w-md\">\n        <CardContent className=\"flex items-center justify-center h-full\">\n          <p className=\"text-muted-foreground\">No todos yet. Add one above!</p>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return (\n    <Card className=\"w-full max-w-md\">\n      <CardHeader>\n        <CardTitle>My Todos</CardTitle>\n      </CardHeader>\n      <CardContent className=\"p-0\">\n        {todos.map((todo) => (\n          <TodoItemComponent \n            key={todo.id} \n            todo={todo} \n            onDelete={onDelete}\n            onUpdate={onUpdate}\n          />\n        ))}\n      </CardContent>\n    </Card>\n  );\n}\n", "client/src/components/CreateTodo.tsx": "\nimport { useState } from 'react';\nimport { Input } from './ui/input';\nimport { Button } from './ui/button';\nimport { Card, CardHeader, CardContent } from './ui/card';\n\ninterface CreateTodoProps {\n  onSubmit: (title: string) => void;\n  isLoading: boolean;\n}\n\nexport function CreateTodo({ onSubmit, isLoading }: CreateTodoProps) {\n  const [title, setTitle] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (title.trim()) {\n      onSubmit(title.trim());\n      setTitle('');\n    }\n  };\n\n  return (\n    <Card className=\"w-full max-w-md mb-4\">\n      <CardHeader>\n        <h2 className=\"text-lg font-semibold\">Add New Todo</h2>\n      </CardHeader>\n      <CardContent>\n        <form onSubmit={handleSubmit} className=\"flex gap-2\">\n          <Input\n            value={title}\n            onChange={(e) => setTitle(e.target.value)}\n            placeholder=\"What needs to be done?\"\n            disabled={isLoading}\n            className=\"flex-1\"\n          />\n          <Button type=\"submit\" disabled={isLoading || !title.trim()}>\n            {isLoading ? 'Adding...' : 'Add'}\n          </Button>\n        </form>\n      </CardContent>\n    </Card>\n  );\n}\n", "client/src/App.tsx": "\nimport { useState, useEffect } from 'react';\nimport { TodoItem } from '../../server/src/schema';\nimport { trpc } from '@/utils/trpc';\nimport { CreateTodo } from './components/CreateTodo';\nimport { TodoList } from './components/TodoList';\nimport './App.css';\n\nfunction App() {\n  const [todos, setTodos] = useState<TodoItem[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isCreating, setIsCreating] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Fetch todos on component mount\n  useEffect(() => {\n    fetchTodos();\n  }, []);\n\n  const fetchTodos = async () => {\n    try {\n      setIsLoading(true);\n      const response = await trpc.listTodos.query({ limit: 100, offset: 0 });\n      setTodos(response.todos || []);\n      setError(null);\n    } catch (err) {\n      setError('Failed to fetch todos');\n      console.error(err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleCreateTodo = async (title: string) => {\n    try {\n      setIsCreating(true);\n      const newTodo = await trpc.createTodo.mutate({ title });\n      setTodos([...todos, newTodo]);\n      setError(null);\n    } catch (err) {\n      setError('Failed to create todo');\n      console.error(err);\n    } finally {\n      setIsCreating(false);\n    }\n  };\n\n  const handleUpdateTodo = async (id: number, updates: { title?: string; completed?: boolean }) => {\n    try {\n      const updatedTodo = await trpc.updateTodo.mutate({ id, ...updates });\n      setTodos(todos.map(todo => todo.id === id ? updatedTodo : todo));\n      setError(null);\n    } catch (err) {\n      setError('Failed to update todo');\n      console.error(err);\n    }\n  };\n\n  const handleDeleteTodo = async (id: number) => {\n    try {\n      await trpc.deleteTodo.mutate({ id });\n      setTodos(todos.filter(todo => todo.id !== id));\n      setError(null);\n    } catch (err) {\n      setError('Failed to delete todo');\n      console.error(err);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col items-center justify-center min-h-screen py-8 px-4\">\n      <h1 className=\"text-3xl font-bold mb-8\">Todo App</h1>\n      \n      {error && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4 w-full max-w-md\">\n          <span className=\"block sm:inline\">{error}</span>\n        </div>\n      )}\n\n      <CreateTodo onSubmit={handleCreateTodo} isLoading={isCreating} />\n      \n      <TodoList \n        todos={todos} \n        onDelete={handleDeleteTodo}\n        onUpdate={handleUpdateTodo}\n        isLoading={isLoading}\n      />\n    </div>\n  );\n}\n\nexport default App;\n", "client/src/App.css": "\n@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');\n\n:root {\n  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, \n    Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n  background-color: #f9fafb;\n  color: #111827;\n}\n\n@media (prefers-color-scheme: dark) {\n  body {\n    background-color: #111827;\n    color: #f9fafb;\n  }\n}\n"}