# TypeScript Development Rules

This file provides specific guidance for TypeScript development in this codebase. Use these guidelines when writing or modifying TypeScript code.

# Key Libraries and Dependencies

- `zod` - Schema validation
- `trpc` - API framework

# Code Organization

## File Structure
- Use a modular approach with clear separation of concerns
- Group related functionality in directories
- Naming pattern: 
  - React components: `ComponentName.tsx`
  - Utility files: `utility-name.ts`
  - Type definitions: `types.ts`

## Import Order
1. React and framework imports
2. Third-party libraries
3. Local components and utilities
4. Types and interfaces
5. Styles and assets

Example:
```typescript
import React, { useState, useEffect } from 'react';

import { z } from 'zod';
import { trpc } from 'trpc';

import { Button } from '../components/Button';
import { formatData } from '../utils/formatter';

import type { User, UserPreferences } from '../types';

import styles from './styles.module.css';
```

# Type Definitions

## Best Practices
- Use explicit interfaces over type aliases for objects
- Use Zod schemas for runtime validation
- Export types from a central location
- Use generics for reusable components and functions

Example:
```typescript
// Define interface
interface User {
  id: string;
  name: string;
  email: string;
  preferences?: UserPreferences;
}

// Define Zod schema
const userSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  email: z.string().email(),
  preferences: userPreferencesSchema.optional(),
});

// Type for function arguments
function updateUser(user: User, updates: Partial<User>): User {
  return { ...user, ...updates };
}
```

# API Integration

## TRPC Patterns
- Define router schemas explicitly
- Use input validation for all procedures
- Centralize error handling

Example:
```typescript
import { z } from 'zod';
import { router, procedure } from '../trpc';

export const userRouter = router({
  getUser: procedure
    .input(z.object({ id: z.string() }))
    .query(async ({ input, ctx }) => {
      try {
        return await ctx.db.user.findUnique({
          where: { id: input.id }
        });
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user',
          cause: error,
        });
      }
    }),
});
```

# Component Structure

## React Components
- Use functional components with hooks
- Destructure props at the component level
- Define prop types using interfaces
- Use React.FC sparingly (prefer explicit return types)

Example:
```typescript
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
}

function Button({ label, onClick, disabled = false }: ButtonProps): JSX.Element {
  return (
    <button 
      onClick={onClick}
      disabled={disabled}
      className={styles.button}
    >
      {label}
    </button>
  );
}
```

# State Management

## Best Practices
- Use React hooks for local state
- Consider context for shared state
- Use reducers for complex state logic
- Keep state normalized

Example:
```typescript
const [state, dispatch] = useReducer(reducer, initialState);

// Later in component
dispatch({ type: 'UPDATE_USER', payload: { id, data } });
```

# Error Handling

## Patterns
- Use try/catch blocks for async operations
- Create custom error classes for domain-specific errors
- Use error boundaries for component errors

Example:
```typescript
try {
  const response = await api.fetchData();
  setData(response);
} catch (error) {
  if (error instanceof ApiError) {
    setError(`API Error: ${error.message}`);
  } else {
    setError('An unexpected error occurred');
    logError(error);
  }
}
```

# Testing

## Patterns
- Use Jest and React Testing Library
- Test component behavior, not implementation
- Mock API calls and external dependencies
- Use data-testid for test selectors

Example:
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { UserProfile } from './UserProfile';

test('displays user information correctly', () => {
  render(<UserProfile user={mockUser} />);
  
  expect(screen.getByText(mockUser.name)).toBeInTheDocument();
  expect(screen.getByText(mockUser.email)).toBeInTheDocument();
  
  fireEvent.click(screen.getByText('Edit Profile'));
  expect(screen.getByTestId('edit-form')).toBeInTheDocument();
});
```

# Common Pitfalls

- Avoid `any` type - use `unknown` if type is truly unknown
- Be careful with nullish values - use optional chaining and nullish coalescing
- Avoid type assertions (`as`) when possible
- Don't use `==` - always use `===` for equality checks
- Remember that empty objects are truthy in JavaScript/TypeScript 